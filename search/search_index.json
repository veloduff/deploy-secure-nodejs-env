{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Deploy a secure Node.js app in a dev environment","text":"<p>There are several options for launching a Node.js dev environment for web applications. For this guide, I'll be using AWS Elastic Beanstalk. The security and knowing what region my data is in, are enough reasons to choose Beanstalk. That said, there are some extra steps that we'll have to take to launch an inexpensive dev environment on Beanstalk. My goal is to keep cost to nothing, or less than $5/month. You can also think about using Amplify, but this guide is using Node.js without React. </p> <p>This guide illustrates the process of launching a secure Node.js application environment, while also minimizing cost (but it is not intended for production). The environment should not cost more then $6/month, and will probably be around $3.50/month. Please ensure that you using an instance that will meet your cost requirements.</p> <p>In addition to this guide, I have created a README on the GitHub repo that performs the steps here, but using a setup command instead of running each command one at a time. Prior to using the setup command, you should at least read this guide to understand what is being done. Go to the veloduff/deploy-secure-nodejs-env repo for more information about using the setup command.</p>"},{"location":"#security-in-mind","title":"Security in mind","text":"<p>It can be very convenient to initially approach projects without consideration for security. For example, using plain text to store passwords or using http instead of https. Rather than having to refactor to meet security requirements later on, I prefer to start with at least some security measures in place already. This is not the easy road, and it is certainly the path less chosen. So if you find yourself spending hours upon hours trying to debug why a cert won't load (bad characters), or why an instance isn't reachable (wrong security group), or why the reverse proxy settings aren't loading (change from AL1 to AL2), you will have found that you are not alone. Security is hard, and not for the weary. With that said, the numerous \"extra\" steps here that you may not want to do, but will result in a secure and inexpensive development environment for running Node.js apps.</p>"},{"location":"#prerequisites","title":"Prerequisites","text":"<p>We will be using the Elastic Beanstalk command line utility, rather than the AWS Console. It is assumed that you have installed the <code>eb</code> command line utility. Details and instructions can be found here: Install the EB CLI. You will also need to configure AWS CLI access. It is also assumed that you have the node development tools installed, as well as <code>git</code>.</p>"},{"location":"#security-starting-at-the-application-layer","title":"Security starting at the application layer","text":"<p>The approach that I have taken here is to use <code>https</code> at the application layer. Specifically, rather than using <code>http.createServer</code> (which in express is the same as <code>app.listen</code>, reference here) we'll be using <code>https.createServer</code> (note the https). This means that we will have to use SSL certificates (although they will be self-signed) to secure the connection from the browser all the way to the application, and not just to the web server (or reverse proxy in this case).</p>"},{"location":"#deployment-strategy-and-overview","title":"Deployment strategy and overview","text":"<p>As we will not be using production features (e.g., Load Balancer, backups, managed updates), this environment that we are setting up is intended to be used for development purposes. To minimize cost we'll be using a single instance (no Load Balancer) Beanstalk environment running on a spot instance (more info on EC2 Spot Instances). The environment should not cost more then $6/month, and will probably be around $3.50/month. Please ensure that you are using an instance that will meet your cost requirements. </p> <p>To deploy a secure Node.js development environment on Beanstalk, we'll need to:</p> <ul> <li>Have an application to deploy that uses https (at the application layer) - I have provided an example app</li> <li>Create two sets of self-signed SSL keys and certificates (one for the web server and one for the application)</li> <li>Create the configuration files for both the Beanstalk environment and the Nginx reverse proxy</li> <li>Create a single instance Beanstalk environment using EC2 Spot </li> </ul>"},{"location":"#how-does-beanstalk-deploy","title":"How does Beanstalk deploy","text":"<p>It is useful to understand both how deployment with Beanstalk happens and what will be included in the deployment. Throughout the process of attempting to deploy environments, I struggled because I did not understand why my changes and updates were not being deployed.</p> <p>Beanstalk deployments are dependent on whether or not you are using <code>.gitignore</code> and <code>.ebignore</code>. For now, let's assume that you are not using a <code>.ebignore</code> file, but you do have a <code>.gitignore</code> (which is probably the most common dev environment). In this scenario, Beanstalk will only deploy changes that have been either staged or committed in your git repo. In other words, Beanstalk uses the git status to deploy your applications. The Beanstalk documentation describes this best:</p> <p>From: Using the EB CLI with Git (Deploying changes)</p> <p>Deploying changes</p> <p>By default, the EB CLI deploys the latest commit in the current branch, using the commit ID and message as the application version label and description, respectively. If you want to deploy to your environment without committing, you can use the --staged option to deploy changes that have been added to the staging area.</p> <p>What this means, is that if you make a change without staging AND committing the change, it will not be included in the next deployment. That said, from the documentation you can see that the changes can be included by only staging (i.e., <code>git add .</code>), and then using the command <code>eb deploy --staged</code>. </p> <p>Another important part of deployment, is whether or not you have a <code>.ebignore</code> file in your project root.</p> <p>From: Configure the EB CLI (Ignoring files using .ebignore)</p> <p>You can tell the EB CLI to ignore certain files in your project directory by adding the file .ebignore to the directory. This file works like a .gitignore file. When you deploy your project directory to Elastic Beanstalk and create a new application version, the EB CLI doesn't include files specified by .ebignore in the source bundle that it creates.</p> <p>If .ebignore isn't present, but .gitignore is, the EB CLI ignores files specified in .gitignore. If .ebignore is present, the EB CLI doesn't read .gitignore.</p> <p>When .ebignore is present, the EB CLI doesn't use git commands to create your source bundle. This means that EB CLI ignores files specified in .ebignore, and includes all other files. In particular, it includes uncommitted source files.</p> <p>There are two very important items to note from this:  1. If <code>.ebignore</code> is present, the EB CLI doesn't read <code>.gitignore</code>.  1. When <code>.ebignore</code> is present, the EB CLI doesn't use git commands to create your source bundle. This means that the EB CLI ignores files specified in <code>.ebignore</code>, and includes all other files. In particular, it includes uncommitted source files. Which is not case if only the <code>.gitignore</code> file exists.</p> <p>With that said, the next steps will document how to setup a straightforward development environment that uses both the <code>.gitignore</code> and <code>.ebignore</code> files in the project's root directory.</p>"},{"location":"#using-beanstalk-configuration-files","title":"Using Beanstalk configuration files","text":"<p>Something that I didn't discover until I had already deployed several apps on Beanstalk, was Advanced environment customization with configuration files (.ebextensions). This allows you to use the <code>.ebextensions</code> folder at your project root directory for Beanstalk configuration files (with extension <code>.config</code>). From the docs:</p> <p>These configuration files are YAML- or JSON-formatted documents with a .config file extension that you place in a folder named .ebextensions and deploy in your application source bundle.</p> <p>For example here is a <code>.ebextensions/network-load-balancer.config</code> file from Advanced environment customization with configuration files (.ebextensions), that modifies a configuration option to set the type of your environment's load balancer to Network Load Balancer.</p> <pre><code> option_settings:\n   aws:elasticbeanstalk:environment:\n     LoadBalancerType: network\n</code></pre> <p>More information, including precedence, can be found here:  Configuration options.</p> <p>Where you can, my suggestion is to use <code>&lt;file&gt;.config</code> files, rather than using command line options or using the AWS Console. This reduces the risk of setting options in more than one place, and also allows you to rebuild environments with the same configuration files.</p> <p>You can use the <code>eb config --display</code> command to show the configuration, or make changes with <code>eb config</code>. You can also use existing (and customized) environments as a template (see eb config).</p> <p>We will be using a file named <code>options.config</code> for Beanstalk configuration settings.</p>"},{"location":"#setup-the-project-environment","title":"Setup the project environment","text":"<p>You have the option of not using <code>git</code> at all, but as that is usually not the case, it's assumed that you will be using <code>git</code>. If you have not already, you should initialize your repo with git, here's an example:</p> <pre><code>$ git init -b main\n$ echo \"# My new repo\" &gt; README.md\n$ git add .\n$ git commit -m \"initial commit\"\n</code></pre>"},{"location":"#create-the-gitignore-and-ebignore-files","title":"Create the <code>.gitignore</code> and <code>.ebignore</code> files","text":"<p>Now you need to setup the <code>.gitignore</code> and <code>.ebignore</code> files. My suggestion is to use a <code>.ebignore</code> file based on a <code>.gitignore</code> file that you would normally use for development. I have a catch-all <code>.gitignore</code> file that I copy to <code>.ebignore</code> and then I add Beanstalk files/dirs I want to ignore to my <code>.gitignore</code> file. In others words, use the <code>.gitignore</code> file you normally use for <code>.ebignore</code>, and then add Beanstalk files/dirs to your <code>.gitignore</code> file. </p> <p>Hopefully these steps help to clarify: 1. Copy an existing <code>.gitignore</code> file to the project root 1. Copy <code>.gitignore</code> to <code>.ebignore</code>  1. Because the SSL keys and certs are stored in files that are in the <code>.ebextensions</code> directory, you need to make sure that the <code>.gitignore</code> file includes the Beanstalk directories, so your keys and certs are not included on a public facing repo. To do this, add the necessary Beanstalk specific dirs/files to the <code>.gitignore</code> file. For example, at the bottom of my <code>.gitignore</code> file, I add this:    <pre><code># Elastic Beanstalk\n.ebextensions/\n.elasticbeanstalk/\n.platform/\n</code></pre></p> <p>NOTE: It's important to remember not to include the above directories in the <code>.ebignore</code> file, otherwise the configuration files will not be included in the deployment.</p>"},{"location":"#more-information-on-the-deployment-workflow","title":"More information on the deployment workflow","text":"<p>On the Extending Elastic Beanstalk Linux platforms page, look at the \"Instance deployment workflow\" for an illustrated introduction for how Beanstalk deployments work.</p>"},{"location":"#project-structure","title":"Project structure","text":"<p>There will be several files and directories that we will be creating (in <code>.ebextensions</code> and other directories). There is an example project directory on the same page mentioned above, if you go to Extending Elastic Beanstalk Linux platforms, and look under \"Application example with extensions\". This has the extensions directory (<code>.ebextensions</code>) and the proxy configuration directory (<code>.platform</code>) as well.</p> <p>For our project, here is the project structure that we will be using (there is nothing to create now, this is just for reference): <pre><code>.\n\u251c\u2500\u2500 .ebextensions\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 options.config\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 sec-group.config\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 ssl-files.config\n\u251c\u2500\u2500 .ebignore\n\u251c\u2500\u2500 .elasticbeanstalk\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 config.yml\n\u251c\u2500\u2500 .env\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 .platform\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 nginx\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 conf.d\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 https.conf\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 nginx.conf\n\u251c\u2500\u2500 app.js\n\u251c\u2500\u2500 package-lock.json\n\u2514\u2500\u2500 package.json\n</code></pre></p>"},{"location":"#create-ssl-keys-and-certificates","title":"Create SSL keys and certificates","text":"<p>Before we do the actual setup of the Beanstalk environment, and because we will be using SSL (https), we're going to first create the SSL key and certificate for the Nginx web server, and second, also create a cert/key for the app itself. By creating two different sets of certs, we are isolating resources. If the app cert is compromised, the web server cert is still safe, and vice versa. For the app cert, the user (e.g., webapp) running the app on the instance will need permissions to access the cert (directory and file permissions). Additionally, we will be using a pass phrase for the app cert. The pass phrase will be included in a Beanstalk environment variable, but can not be seen in the github repo (and we'll use <code>.env</code> for local testing and put <code>.env</code> in the <code>.gitignore file</code>).</p> <p>We're going to use self-signed certificates, created with <code>openssl</code>.</p> <p>The cert used for the web server will not have a pass phrase, because we want the web server to be able restart without having to enter the pass phrase. The application cert will have a pass phrase that we provide as part of the environment in Beanstalk, but the pass phrase will not be visible on the github repo.</p>"},{"location":"#for-the-web-server-create-a-key-and-cert-without-using-a-pass-phrase","title":"For the web server: Create a key and cert without using a pass phrase","text":"<p>This command will generate an RSA private key file (saved in PEM format):</p> <pre><code>$ openssl genpkey -algorithm RSA -pkeyopt rsa_keygen_bits:4096 -out myWebServerKey.pem \n..........................................................................++++\n.....................................................................................................................++++\n</code></pre> <p>This next command will create the certificate request file (also in PEM format) using the key file just created. I'm using the domain <code>*.elasticbeanstalk.com</code> to remind me what the cert is intended for, but you should be able use any domain you want.</p> <pre><code>$ openssl req -x509 -new -sha256 -key myWebServerKey.pem -out myWebServerCertReq.pem -subj '/C=US/ST=California/L=SJC/O=MyOrg1/CN=*.elasticbeanstalk.com'\n</code></pre>"},{"location":"#for-the-application-create-a-key-and-cert-using-a-pass-phrase","title":"For the application:  Create a key and cert using a pass phrase","text":"<p>We'll use the <code>openssl</code> command to generate pass phrase, and save it to a file to avoid STDOUT (and avoid command line history and ps info): <pre><code>$ openssl rand -base64 32 &gt; pass_phrase.txt\n</code></pre></p> <p>This next command will generate an RSA private key file (saved in PEM format), using the pass phrase we just created as input: <pre><code>$ openssl genpkey -algorithm RSA -pkeyopt rsa_keygen_bits:4096 -aes-256-cbc -pass file:pass_phrase.txt -out myAppKey1.pem\n</code></pre></p> <p>And now create the certificate request file (also in PEM format) using the key file we just created and the pass phrase file as input. <pre><code>$ openssl req -x509 -new -sha256 -key myAppKey1.pem -passin file:pass_phrase.txt -out myAppCertReq1.pem -subj '/C=US/ST=California/L=SJC/O=MyApp1/CN=*.elasticbeanstalk.com'\n</code></pre></p> <p>NOTE: You will need these five files (two cert files, two key files, one pass phrase file) in later steps to build the <code>ssl-files.config</code> file.</p>"},{"location":"#setup-local-testing-environment","title":"Setup local testing environment","text":"<p>For local testing, you'll need to setup a <code>.env</code> file (used by the dotenv package) with cert and key information to be used by your application. Make sure that <code>.env</code> is in your <code>.gitignore</code> file. In your project root, create the <code>.env</code> file with the pass phrase, the location of the application cert and key (which is in a directory you choose), and their file names on your local machine:</p> <pre><code># location: .env (of project root)\nPKEY_PASSPHRASE: '&lt;pass_phrase_for_private_key&gt;'\nLOCAL_KEY_DIR = '../Certificates/'\nAPP_KEY_NAME = 'myAppKey1.pem'\nAPP_CERT_NAME = 'myAppCertReq1.pem'\n</code></pre>"},{"location":"#test-locally","title":"Test locally","text":"<p>In the interest of showing an end-to-end process, I am including the example code below. This is an app that will create a session (cookie) if the connection is using https from the browser to the app.</p> <p>Here the are steps to create the app. First, initialize the node project with ES6 to support <code>type: module</code>, and then install needed packages: <pre><code>$ npm init es6 -y\n$ npm i express express-session dotenv body-parser\n</code></pre></p> <p>Create the <code>app.js</code> file with this: <pre><code>import dotenv from 'dotenv';\ndotenv.config();\n\nimport * as fs from 'fs';\nimport express from 'express';\nimport bodyParser from 'body-parser';\nimport session from 'express-session';\n\nconst RUNTIME_ENV = process.env.NODE_ENV || 'development';\n\nconst app = express()\nconst securePort = 3030;\napp.use(bodyParser.urlencoded({ extended: true }));\n\nlet https;\ntry {\n  https = await import('node:https');\n} catch (err) {\n  console.error('https support is disabled!');\n}\n\napp.use(session({\n  secret: 'keyboard cat',\n  resave: false,\n  saveUninitialized: true,\n  cookie: {\n    secure: true,\n    httpOnly: true,\n  }\n}))\n\napp.route('/')\n  .get((req, res) =&gt; {\n    res.setHeader('Content-type', 'text/html');\n    res.write(\n    ` &lt;!DOCTYPE html&gt; \n      &lt;html&gt;&lt;head&gt;&lt;title&gt;Session example&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\n      &lt;div style=\"text-align:center; margin: 0 auto; max-width: 550px;\"&gt;\n        &lt;br&gt;&lt;br&gt;\n        &lt;h3&gt;Session (cookies) example&lt;/h3&gt;\n          &lt;p&gt;\n            This is an example of a session. You should see a \"Secure\" \n            and \"HttpOnly\" cookie set for this page, and when you enter \n            a word it will be stored with the session. If you delete the \n            cookie, the session information and the word you entered \n            will be deleted.\n          &lt;/p&gt;\n        &lt;form action=\"/\" method=\"POST\"&gt;\n          &lt;input type=\"text\" name=\"anyword\"&gt;\n          &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;\n        &lt;/form&gt; \n        &lt;br&gt;`\n    );\n    res.write('Entered word: &lt;b&gt;' + (req.session.anyword || 'no word entered') + '&lt;/b&gt;');\n    res.write('&lt;/div&gt;&lt;/body&gt; &lt;/html&gt;')\n    res.status(200).send();\n  })\n  .post((req, res) =&gt; {\n    req.session.anyword = req.body.anyword;\n    res.status(302).redirect('/');\n  })\n\nlet keyDirectory = process.env.LOCAL_KEY_DIR;\nif (RUNTIME_ENV === 'production') {\n  keyDirectory = '/home/webapp/appCert/';\n} \n\nconst appKeyName = process.env.APP_KEY_FILE || 'app1.key';\nconst appCertName = process.env.APP_CERT_FILE || 'app1.crt';\nconst httpsOptions = {\n  key: fs.readFileSync(keyDirectory + appKeyName),\n  cert: fs.readFileSync(keyDirectory + appCertName),\n  passphrase: process.env.PKEY_PASSPHRASE \n}\n\nconst httpsServer = https.createServer(httpsOptions, app)\n  .listen(process.env.PORT || securePort, () =&gt; {\n    console.log('https server started on port ' + \n     httpsServer.address().port + ' running in ' + RUNTIME_ENV);\n  })\n</code></pre></p> <p>Test locally by using: <pre><code>$ node app.js\n</code></pre> And you should see the app running https://localhost:3030 (note the https)</p>"},{"location":"#initialize-and-deploy-on-beanstalk","title":"Initialize and deploy on Beanstalk","text":""},{"location":"#initialize-the-application","title":"Initialize the application","text":"<p>We will be using the Elastic Beanstalk command line. Our next step is to initialize the application with <code>eb init</code> in the project root. The <code>eb init</code> command will ask several questions to setup the application, to include setting up your access and secret keys. Make sure that you are selecting the correct information (region, Node.js version, etc.)</p> <p>Here is an example run:</p> <pre><code>$ eb init\n\nSelect a default region\n1) us-east-1 : US East (N. Virginia)\n2) us-west-1 : US West (N. California)\n3) us-west-2 : US West (Oregon)\n... (many regions omitted) ...\n(default is 1): 3\n\nSelect an application to use\n1) test-app-1 \n2) [ Create new Application ]\n(default is 2): 2\n\nEnter Application Name\n(default is \"eb-testing-1\"): eb-testing-app-1\nApplication eb-testing-app-1 has been created.\n\nIt appears you are using Node.js. Is this correct?\n(Y/n):\nSelect a platform branch.\n1) Node.js 18 running on 64bit Amazon Linux 2\n2) Node.js 16 running on 64bit Amazon Linux 2\n3) Node.js 14 running on 64bit Amazon Linux 2\n(default is 1): 1\n\nDo you wish to continue with CodeCommit? (Y/n): n\nDo you want to set up SSH for your instances? (Y/n): y\n</code></pre> <p>You can also run the <code>eb init</code> command with arguments to answer some or all of the questions: <pre><code>eb init -r us-west-2 -p node.js eb-testing-app-1 \n</code></pre></p>"},{"location":"#configure-your-deployment","title":"Configure your deployment","text":"<p>We will be using several files to configure the Beanstalk environment. To be specific, and looking at the directory tree again, we'll be using these files for customization:</p> <pre><code>.\n\u251c\u2500\u2500 .ebextensions\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 options.config\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 sec-group.config\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 ssl-files.config\n...\n\u251c\u2500\u2500 .platform\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 nginx\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 conf.d\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 https.conf\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 nginx.conf\n...\n</code></pre> <p>At your project root, create the directories for the configuration files: <pre><code>$ mkdir .ebextensions\n$ mkdir -p .platform/nginx/conf.d\n</code></pre></p> <p>Now we will go through the process of creating each file that will be used for deployment.</p>"},{"location":"#create-the-ebextensionsoptionsconfig-file","title":"Create the <code>.ebextensions/options.config</code> file","text":"<p>For the <code>options.config</code> file, you'll need to add environment variables. Specifically: 1. The port number that your app will be running on. 1. The pass phrase for the application key file (the one from the <code>pass_phrase.txt</code> file above). 1. Set the <code>NODE_ENV</code> to <code>production</code>. Although this is a dev environment, this helps separate local development (dev) and running on Beanstalk (prod)</p> <p>Here is the <code>.ebextensions/options.config</code> file: <pre><code>option_settings:\n  aws:elasticbeanstalk:application:environment:\n    PORT: 5000\n    PKEY_PASSPHRASE: '&lt;pass_phrase_for_private_key&gt;'\n    NODE_ENV: 'production'\n</code></pre></p>"},{"location":"#create-the-ebextensionsssl-filesconfig-file","title":"Create the <code>.ebextensions/ssl-files.config</code> file","text":"<p>This file instructs Beanstalk to create the SSL key and cert files on the instance that will be used by the Nginx reverse proxy and your application. For the template below, you will need to use the self-signed keys and certificates that you created to replace everything that is between the <code>-----BEGIN ...</code> and <code>-----END ...</code>.</p> <p>The web server key and cert will be created in the directory <code>/etc/pki/tls/certs/</code> and owned by <code>root</code>. The application key and cert will be created in the directory <code>/home/webapp/appCert/</code> and owned by the user <code>webapp</code>. Both the keys and certificates are set to read only only by the owner (i.e., root or webapp).</p> <p>Alignment is very important and you have to use only spaces, not tabs.</p> <pre><code># location: .ebextensions/ssl-files.config\n\nfiles:\n\n  /etc/pki/tls/certs/server.crt:\n    mode: \"000400\"\n    owner: root\n    group: root\n    content: |\n      -----BEGIN CERTIFICATE-----\n      ASASFWEASEF124508asdfaASDF12508125asdfasdf082531808asdfasdf08080\n      ASASFWEASEF                                         sdfasdf08080\n      ASASFWEASEF     WEB SERVER CERTIFICATE FILE HERE    sdfasdf08080\n      ASASFWEASEF                                         sdfasdf08080\n      ASASFWEASEF124508asdfaASDF12508125asdfasdf082531808asdfasdf08080\n      ASASFWEASEF124508asdfa==\n      -----END CERTIFICATE-----\n\n  /etc/pki/tls/certs/server.key:\n    mode: \"000400\"\n    owner: root\n    group: root\n    content: |\n      -----BEGIN PRIVATE KEY-----\n      ASASFWEASEF124508asdfaASDF12508125asdfasdf082531808asdfasdf08080\n      ASASFWEASEF                                         sdfasdf08080\n      ASASFWEASEF    WEB SERVER PRIVATE KEY FILE HERE     sdfasdf08080\n      ASASFWEASEF                                         sdfasdf08080\n      ASASFWEASEF124508asdfaASDF12508125asdfasdf082531808asdfasdf08080\n      ASASFWEASEF124508asdfa==\n      -----END PRIVATE KEY-----\n\n  /home/webapp/appCert/app1.crt:\n    mode: \"000400\"\n    owner: webapp\n    group: webapp \n    content: |\n      -----BEGIN CERTIFICATE-----\n      ASASFWEASEF124508asdfaASDF12508125asdfasdf082531808asdfasdf08080\n      ASASFWEASEF                                          dfasdf08080\n      ASASFWEASEF     APPLICATION CERTIFICATE FILE HERE    dfasdf08080\n      ASASFWEASEF                                          dfasdf08080\n      ASASFWEASEF124508asdfaASDF12508125asdfasdf082531808asdfasdf08080\n      ASASFWEASEF124508asdfa==\n      -----END CERTIFICATE-----\n\n  /home/webapp/appCert/app1.key:\n    mode: \"000400\"\n    owner: webapp\n    group: webapp \n    content: |\n      -----BEGIN ENCRYPTED PRIVATE KEY-----\n      ASASFWEASEF124508asdfaASDF12508125asdfasdf082531808asdfasdf08080\n      ASASFWEASEF                                          dfasdf08080\n      ASASFWEASEF    APPLICATION PRIVATE KEY FILE HERE     dfasdf08080\n      ASASFWEASEF                                          dfasdf08080\n      ASASFWEASEF124508asdfaASDF12508125asdfasdf082531808asdfasdf08080\n      ASASFWEASEF124508asdfa==\n      -----END ENCRYPTED PRIVATE KEY-----\n</code></pre>"},{"location":"#create-the-ebextensionssec-groupconfig-file","title":"Create the <code>.ebextensions/sec-group.config</code> file","text":"<p>The <code>.ebextensions/sec-group.config</code> file is used to open port 443 on the instance, update the <code>CidrIp</code> to restrict access to a specific IP or CIDR block:</p> <pre><code># location: .ebextensions/sec-group.config \nResources:\n  sslSecurityGroupIngress: \n    Type: AWS::EC2::SecurityGroupIngress\n    Properties:\n      GroupId: {\"Fn::GetAtt\" : [\"AWSEBSecurityGroup\", \"GroupId\"]}\n      IpProtocol: tcp\n      ToPort: 443\n      FromPort: 443\n      CidrIp: 0.0.0.0/0\n</code></pre>"},{"location":"#create-the-platformnginxconfdhttpsconf-file","title":"Create the <code>.platform/nginx/conf.d/https.conf</code> file","text":"<p>A note about the https configuration</p> <p>The configurations templates that I am using are found in the official AWS Elastic Beanstalk documentation: Configuring your application to terminate HTTPS connections at the instance. The config file to setup https on a single instance will need the file location, syntax, and the <code>listen</code> line to be updated, which I found on the re:Post article How do I configure an SSL certificate for an application running in an Elastic Beanstalk environment? in the section Terminate HTTPS at instance level. That same article also does a great job of explaining the move from AL1 to AL2.</p> <p>NOTE: There is a difference between using Amazon Linux 1 and Amazon Linux 2. When configuring the Nginx reverse proxy, the location for files that are used to extend the Nginx configuration has moved to <code>.platform/nginx/conf.d/</code>. If you want to completely replace the Nginx configuration then you use <code>.platform/nginx/nginx.conf</code> (which we will be doing). More details can be found in the section \"Configuring nginx\" in Extending Elastic Beanstalk Linux platforms, and also Migrating your Elastic Beanstalk Linux application to Amazon Linux 2.</p> <p>We configure Nginx to listen on port 443, by creating the <code>.platform/nginx/conf.d/https.conf</code> with the config info below. <code>proxy_pass</code> has to point to <code>https</code> and we need to use the port number that we used for <code>PORT</code> in the <code>options.config</code> file we created above. This configures Beanstalk to use port 5000 to run your application. In your application you do not need to hard-code the port number, you can use, for example: <code>process.env.PORT || 3030</code>.</p> <p>Here is the entire <code>.platform/nginx/conf.d/https.conf</code> you should use:</p> <pre><code># HTTPS server\n# location: .platform/nginx/conf.d/https.conf\n\nserver {\n  listen       443 ssl;\n  server_name  localhost;\n\n  ssl_certificate      /etc/pki/tls/certs/server.crt;\n  ssl_certificate_key  /etc/pki/tls/certs/server.key;\n\n  ssl_session_timeout  5m;\n\n  ssl_protocols  TLSv1 TLSv1.1 TLSv1.2;\n  ssl_prefer_server_ciphers   on;\n\n  location / {\n          ## proxy_pass has to point to https and the port number used for PORT in the options.conf file\n          proxy_pass  https://localhost:5000;\n          proxy_set_header   Connection \"\";\n          proxy_http_version 1.1;\n          proxy_set_header        Host            $host;\n          proxy_set_header        X-Real-IP       $remote_addr;\n          proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;\n          proxy_set_header        X-Forwarded-Proto https;\n  }\n}\n</code></pre>"},{"location":"#create-the-platformnginxnginxconf-file","title":"Create the <code>.platform/nginx/nginx.conf</code> file","text":"<p>For the redirect to work after initial deployment, edit the main Nginx conf file (<code>.platform/nginx/nginx.conf</code>). I added an https redirect from port 80. Specifically, I added this to the server listening on port 80:</p> <pre><code>        # Permanently redirecting to https\n        return 301 https://$host$request_uri;\n</code></pre> <p>This is has resulted in a predicable environment launching, with the redirect to https working. Here is the entire <code>.platform/nginx/nginx.conf</code> file:</p> <pre><code># Elastic Beanstalk Nginx Configuration File\n# Added redirect\n# location .platform/nginx/nginx.conf\n\nuser                    nginx;\nerror_log               /var/log/nginx/error.log warn;\npid                     /var/run/nginx.pid;\nworker_processes        auto;\nworker_rlimit_nofile    31486;\n\nevents {\n    worker_connections  1024;\n}\n\nhttp {\n    server_tokens off;\n\n    include       /etc/nginx/mime.types;\n    default_type  application/octet-stream;\n\n    log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n                      '$status $body_bytes_sent \"$http_referer\" '\n                      '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n\n    include       conf.d/*.conf;\n\n    map $http_upgrade $connection_upgrade {\n        default     \"upgrade\";\n    }\n\n    server {\n        listen        80 default_server;\n        access_log    /var/log/nginx/access.log main;\n\n        client_header_timeout 60;\n        client_body_timeout   60;\n        keepalive_timeout     60;\n        gzip                  off;\n        gzip_comp_level       4;\n        gzip_types text/plain text/css application/json application/javascript application/x-javascript text/xml application/xml application/xml+rss text/javascript;\n\n        # Include the Elastic Beanstalk generated locations\n        include conf.d/elasticbeanstalk/*.conf;\n\n        # Permanently redirecting to https\n        return 301 https://$host$request_uri;\n    }\n}\n</code></pre>"},{"location":"#verify-config-files","title":"Verify config files","text":"<p>You should now verify that you have created each of the files above, here are the files you should have created:</p> <pre><code>.ebextensions/options.config\n.ebextensions/sec-group.config\n.ebextensions/ssl-files.config\n.platform/nginx/conf.d/https.conf\n.platform/nginx/nginx.conf\n</code></pre>"},{"location":"#create-the-beanstalk-environment-this-deploys-as-well","title":"Create the Beanstalk environment (this deploys as well)","text":"<p>The next steps depend on the steps above, to include <code>eb init</code>. We'll be using the eb create command. This command will deploy a single instance, without a load balancer, and we will use spot instances with the specified instance types: <pre><code>eb create --single --enable-spot --instance-types t3.nano,t3.micro myEnvOnEb \n</code></pre></p> <p>Once the deployment is finished you can go to the Elastic Beanstalk dashboard and click on the \"Go to environment\" link, or click on the Domain, which will look something like this:</p> <p>myEnvOnEb.eba-sadf23ds.us-west-2.elasticbeanstalk.com</p> <p>When viewing in your browser, it should not matter if you use <code>http://</code> or <code>https://</code> for the url, you should be redirected to the https page. As we are using a self-signed certificate, you will see a warning that looks like this:</p> <p></p> <p>Click on \"Advanced\" and then click on the message that says something similar to this \"Proceed to myEnvOnEb.eba-srwf23ds.us-west-2.elasticbeanstalk.com (unsafe)\".</p> <p>You should see your app running on https, and you can check the certificate by clicking on the \"Not Secure\" button next to the URL.</p> <p></p>"},{"location":"#check-that-the-session-is-secure-and-using-httponly","title":"Check that the session is Secure and using HttpOnly","text":"<p>Use Chrome to load the page, and go to \"View\" -&gt; \"Developer\" -&gt; \"Developer Tools\". And then click on the \"Application\" tab, and in the \"Storage\" section, you should see \"Cookies\" and under that you should see the cookie that was set by the Node.js application. Both \"HttpOnly\" and \"Secure\" should be checked:</p> <p></p>"},{"location":"#remove-and-reset","title":"Remove and reset","text":"<p>You can go to the AWS Console to see which environments are running and remove them there. Or to remove an application environment (and applications) with the CLI, use <code>eb list</code> to show your environments, and <code>eb terminate</code> to remove them.</p> <p>This terminates one env, but will leave the application:</p> <pre><code>[~/repos/app-testing]$ eb terminate &lt;env_name&gt;\n</code></pre> <p>This terminates all environments and deletes the application:</p> <pre><code>[~/repos/app-testing]$ eb terminate --all\n</code></pre> <p>If you need to reset your environment, you can remove all the files and directories that were created by the setup command:</p> <pre><code>rm -ri .ebignore .gitignore .platform .ebextensions .elasticbeanstalk .env &lt;certificate_directory&gt;\n</code></pre>"},{"location":"#conclusion","title":"Conclusion","text":"<p>We're done! We have setup a secure, inexpensive Node.js development environment on AWS Elastic Beanstalk. This environment (if running 24/7), would cost about $6/month (using today's EC2 Spot prices). You now have the option of scaling to a production environment that would include a Load Balancer and official (not self-signed) SSL certificates. The setup for using SSL and redirecting to https is much easier when using a Load Balancer, as that is one of the functions that a Load Balancer was designed to do (but will cost more).</p> <p>For just general tips for launching a Node.js application on Beanstalk, but not specific to https, have a look at: Node.js app on Beanstalk</p>"},{"location":"#additional-configuration","title":"Additional configuration","text":"<p>In the <code>ebFileTemplates.py</code> file you will find the templates that are used to create each of the files. You can customize those as needed. For example, to add Managed updates and to enable access to static files in the <code>/public</code> directory, add this to <code>.ebextensions/options.config</code>: </p> <pre><code>option_settings:\n  aws:elasticbeanstalk:managedactions:\n    ManagedActionsEnabled: true\n    PreferredStartTime: \"Mon:10:00\"\n  aws:elasticbeanstalk:managedactions:platformupdate:\n    UpdateLevel: patch\n    InstanceRefreshEnabled: true\n  aws:elasticbeanstalk:environment:proxy:staticfiles:\n    /public: /public\n</code></pre>"}]}